% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ProjKrigSp.R
\name{ProjKrigSp}
\alias{ProjKrigSp}
\title{Kriging using projected normal model.}
\usage{
ProjKrigSp(ProjSp_out, coords_obs, coords_nobs, x_obs)
}
\arguments{
\item{ProjSp_out}{the function takes the output of \code{\link{ProjSp}} function}

\item{coords_obs}{coordinates of observed locations (in UTM)}

\item{coords_nobs}{coordinates of unobserved locations (in UTM)}

\item{x_obs}{observed values in \eqn{[0,2\pi)}.
If they are not in \eqn{[0,2\pi)}, the function will transform
the data in the right interval}
}
\value{
a list of 3 elements
\describe{
\item{\code{M_out}}{the mean of the associated linear process on the prediction locations  coords_nobs (rows) over all the posterior samples (columns) returned by ProjSp}
\item{\code{V_out}}{the variance of the associated linear process on the prediction locations  coords_nobs (rows) over all the posterior samples (columns) returned by ProjSp}
\item{\code{Prev_out}}{the posterior predicted  values at the unobserved locations.}
}
}
\description{
\code{ProjKrigSp} function computes the spatial prediction
for circular spatial data using samples from the posterior distribution
of the spatial projected normal
}
\examples{
\dontrun{
# simulated data
library(CircSpaceTime)
rmnorm <- function( n = 1,
                    mean = rep(0, d),
                    varcov) {
  d <- if (is.matrix(varcov))
  ncol(varcov)
  else 1
  z <- matrix(rnorm(n * d), n, d) \%*\% chol(varcov)
  y <- t(mean + t(z))
  return(y)
  }
 ####
 # Simulation
 ####
 set.seed(1)
 n = 100
 coords <- cbind(runif(n,0,100), runif(n,0,100))
 Dist <- as.matrix(dist(coords))
 rho     <- 0.05
 tau     <- 0.2
 sigma2  <- 0.3
 alpha   <- c(0.5, 0.2)
 SIGMA   <- sigma2*exp(-(rho*Dist)) #exponential covariance function
 Y <- rmnorm(1,rep(alpha,times=n),
        kronecker(SIGMA,
           matrix(c( sigma2,sqrt(sigma2)*tau,sqrt(sigma2)*tau,1 ) ,
               nrow=2 )
         )
       )
#Projection step
 theta = c()
 for(i in 1:n)
 {
  theta[i] <- atan2(Y[(i-1)*2+2],Y[(i-1)*2+1])
 }

rose_diag(theta)

 val <- sample(1:n,round(n*0.1))
 set.seed(100)

 #### Posterior estimation
 mod_exp <- ProjSp(
   x       = theta[-val],
   coords    = coords[-val,],
   start   = list("alpha"      = c(1,1),
                 "rho"     = c(0.1),
                 "tau"     = c(0.1),
                 "sigma2"    = c(0.1),
                 "r"       = abs(rnorm(  length(theta))  )),
   priors   = list("rho"      = c(0.03,3),
                   "tau"      = c(-1,1),
                   "sigma2"    = c(5,5),
                   "alpha_mu" = c(0, 0),
                   "alpha_sigma" = diag(10,2)),
 sd_prop   = list("sigma2" = 0.1,
                  "tau" = 0.1,
                  "rho" = 0.1,
                  "sdr" = sample(.05,length(theta),
                  replace = T)),
  iter    = 36000,
  BurninThin    = c(burnin = 20000, thin = 8),
  accept_ratio = 0.234,
  adapt_param = c(start = 1, end = 1000, exp = 0.5),
  corr_fun = "exponential")

 # check convergence graphically, with multiple chains the function ConvCheck can be used

 par(mfrow=c(2,1))
 plot(mod_exp[[1]]$alpha[1,],type="l")
 abline(h=alpha[1],col=2)

 plot(mod_exp[[1]]$alpha[2,],type="l")
 abline(h=alpha[2],col=2)

 par(mfrow=c(3,1))
 plot(mod_exp[[1]]$sigma2[],type="l")
 abline(h=sigma2[1],col=2)

 plot(mod_exp[[1]]$rho[],type="l")
 abline(h=rho[1],col=2)

 plot(mod_exp[[1]]$tau[],type="l")
 abline(h=rho[1],col=2)

 par(mfrow=c(1,1))
# move to prediction once convergence is achieved
Krig <- WrapKrigSp(
    WrapSp_out = mod_exp,
    coords_obs =  coords[-val,],
    coords_nobs =  coords[val,],
    x_obs = theta[-val]
    )

# The quality of prediction can be checked using APEcirc and CRPScirc
}
}
\references{
F. Wang, A. E.   Gelfand,
 "Modeling space and space-time directional data using projected Gaussian processes",
 Journal of the American Statistical Association,109 (2014), 1565-1580

G. Mastrantonio, G. Jona Lasinio, A. E. Gelfand,
"Spatio-temporal circular models with non-separable covariance structure",
TEST 25 (2016), 331-350 https://doi.org/10.1007/s11749-015-0458-y
}
\seealso{
\code{\link{ProjSp}} for spatial sampling from
 Projected Normal ,
 \code{\link{WrapSp}} for spatial sampling from
 Wrapped Normal and \code{\link{WrapKrigSp}} for
 spatial interpolation under the wrapped model

Other spatial interpolations: \code{\link{WrapKrigSp}}
}
\concept{spatial interpolations}
